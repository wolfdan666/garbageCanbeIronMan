# 技术
3小时40分钟
## github commit信息连接设置
40分钟

先用这个测试一下是否成功了

## mysql
180分钟(3小时) 下次从第16章开始

在家里中途可以躺着休息真的爽，放松到位，加油学习吧
### 14章 MySQL基于规则的优化 摘要
**外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃。**

**我们知道WHERE子句的杀伤力比较大，凡是不符合WHERE子句中条件的记录都不会参与连接。**

我们把这种在外连接查询中，指定的WHERE子句中包含被驱动表中的列不为NULL值的条件称之为空值拒绝（英文名：reject-NULL）。**在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。**这种转换带来的好处就是**查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。**

#### 子查询真实过程
```sql
SELECT * FROM tbl_name WHERE column IN (a, b, c ..., ...);
```
这样每条记录需要判断一下它的column列是否符合`column = a OR column = b OR column = c OR ...`，这样性能耗费可就多了。

于是乎设计MySQL的大佬想了一个招：**不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里。**写入临时表的过程是这样的：

- 该临时表的列就是子查询结果集中的列。
- 写入临时表的记录会被去重。
我们说IN语句是判断某个操作数在不在某个集合中，集合中的值重不重复对整个IN语句的结果并没有什么子关系，所以我们在将结果集写入临时表时对记录进行去重可以让临时表变得更小，更省地方～
>小贴士：临时表如何对记录进行去重？这不是小意思嘛，临时表也是个表，只要为表中记录的所有列建立主键或者唯一索引就好了嘛～
- 一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用Memory存储引擎的临时表，而且会为该表建立希索引。
>小贴士：IN语句的本质就是判断某个操作数在不在某个集合里，如果集合中的数据建立了哈希索引，那么这个匹配的过程就是超级快的。  
>有同学不知道哈希索引是什么？我这里就不展开了，自己上网找找吧，不会了再来问我～

如果子查询的结果集非常大，超过了系统变量tmp_table_size或者max_heap_table_size，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为B+树索引。

设计MySQL的大佬把这个将子查询结果集中的记录保存到临时表的过程称之为**物化**（英文名：Materialize）。为了方便起见，我们就把那个存储子查询结果集的临时表称之为物化表。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行IN语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。

其实上面的查询就相当于表s1和子查询物化表materialized_table进行内连接：
```sql
SELECT s1.* FROM s1 INNER JOIN materialized_table ON key1 = m_val;
```
转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。我们分析一下上述查询中使用外层查询的表s1和物化表materialized_table进行内连接的成本都是由哪几部分组成的：

- 如果使用s1表作为驱动表的话，总查询成本由下面几个部分组成：
  - 物化子查询时需要的成本
  - 扫描s1表时的成本
  - s1表中的记录数量 × 通过m_val = xxx对materialized_table表进行单表访问的成本（我们前面说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。
- 如果使用materialized_table表作为驱动表的话，总查询成本由下面几个部分组成：
  - 物化子查询时需要的成本
  - 扫描物化表时的成本
  - 物化表中的记录数量 × 通过key1 = xxx对s1表进行单表访问的成本（非常庆幸key1列上建立了索引，所以这个步骤是非常快的）。

MySQL查询优化器会通过运算来选择上述成本更低的方案来执行查询。

#### 子查询转为内连接的一些摘要
对于某些使用IN语句的**相关**子查询，比方这个查询：

```sql
SELECT * FROM s1 
  WHERE key1 IN (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3);
```
它也可以很方便的转为半连接，转换后的语句类似这样：

```sql
SELECT s1.* FROM s1 SEMI JOIN s2 
    ON s1.key1 = s2.common_field AND s1.key3 = s2.key3;
```
然后就可以使用我们上面介绍过的DuplicateWeedout、LooseScan、FirstMatch等半连接执行策略来执行查询，当然，如果子查询的查询列表处只有主键或者唯一二级索引列，还可以直接使用table pullout的策略来执行查询，但是需要大家注意的是，**由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询。**

#### semi-join的适用条件
当然，并不是所有包含IN子查询的查询语句都可以转换为semi-join，只有形如这样的查询才可以被转换为semi-join：

```sql
SELECT ... FROM outer_tables 
    WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...
```
或者这样的形式也可以：

```sql
SELECT ... FROM outer_tables 
    WHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...
```
用文字总结一下，只有符合下面这些条件的子查询才可以被转换为semi-join：

- 该子查询必须是和IN语句组成的布尔表达式，并且在外层查询的WHERE或者ON子句中出现。
- 外层查询也可以有其他的搜索条件，只不过和IN子查询的搜索条件必须使用AND连接起来。
- 该子查询必须是一个单一的查询，不能是由若干查询由UNION连接起来的形式。
- 该子查询不能包含GROUP BY或者HAVING语句或者聚集函数。
- ... 还有一些条件比较少见，就不介绍啦～

#### semi-join小结
- 如果IN子查询符合转换为semi-join的条件，查询优化器会优先把该子查询为semi-join，然后再考虑下面5种执行半连接的策略中哪个成本最低：
  - Table pullout
  - DuplicateWeedout
  - LooseScan
  - Materialization
  - FirstMatch
选择成本最低的那种执行策略来执行子查询。

- 如果IN子查询不符合转换为semi-join的条件，那么查询优化器会从下面两种策略中找出一种成本更低的方式执行子查询：
  - 先将子查询物化之后再执行查询
  - 执行IN to EXISTS转换。

### 15-查询优化的百科全书-Explain详解
#### id代表select个数，然后table顺序就是先驱动后被驱动
**在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表**

但是这里大家需要特别注意，<span style="color:red">查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</span>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：
```bash
mysql> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field =
'a');
+----+-------------+-------+------------+------+---------------+----------+---------+-----
--------------+------+----------+------------------------------+
| id | select_type | table | partitions | type | possible_keys | key | key_len | ref
| rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+----------+---------+-----
--------------+------+----------+------------------------------+
| 1 | SIMPLE | s2 | NULL | ALL | idx_key3 | NULL | NULL | NULL
| 9954 | 10.00 | Using where; Start temporary |
| 1 | SIMPLE | s1 | NULL | ref | idx_key1 | idx_key1 | 303 | xiao
haizi.s2.key3 | 1 | 100.00 | End temporary |
+----+-------------+-------+------------+------+---------------+----------+---------+-----
--------------+------+----------+------------------------------+
2 rows in set, 1 warning (0.00 sec)
```

可以看到，虽然我们的查询语句是一个子查询，但是执行计划中 s1 和 s2 表对应的记录的 id 值全部是 1 ，这就表明了查询优化器将子查询转换为了连接查询。


#### 二级索引和聚簇索引的遍历
>小贴士：
>再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。

#### possible_keys
另外需要注意的一点是，possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。


# 看书
斯多葛主义 30分钟
# 运动
10分钟

60仰卧起坐，30卧抬起

# 总结
加4个自信币和4个自信点