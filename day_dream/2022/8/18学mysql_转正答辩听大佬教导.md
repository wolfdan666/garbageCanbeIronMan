# 技术
60分钟
## Mysql
60分钟，看到这里: 

>Redundant 行格式多了 n_field 和 1byte_offs_flag 这两个属性。
>Redundant 行格式没有 record_type 这个属性。
>1byte_offs_flag的值是怎么选择的


### 变长长度规则
如果M×W > 255，则分为两种情况：

如果L <= 127，则用1个字节来表示真正字符串占用的字节数。
如果L > 127，则用2个字节来表示真正字符串占用的字节数。

InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，**该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？**设计InnoDB的大佬使用该字节的第一个二进制位作为标志位：**如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。**
对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会介绍），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。

Notice: **前导是否为0，表示是否是单独表示一个字段长度**


### InnoDB的隐藏列
这里需要提一下InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为`row_id`的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 `transaction_id` 和 `roll_pointer` 这两个列，但是 `row_id` 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心，InnoDB存储引擎会自己帮我们生成的。

### 字符集也影响列是否存在变长字段长度列表里面
这就意味着：对于 `CHAR(M)` 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

另外有一点还需要注意，变长字符集的CHAR(M)类型的列要求至少占用M个字节，而VARCHAR(M)却没有这个要求。比方说对于使用utf8字符集的CHAR(10)的列来说，该列存储的数据字节长度的范围是10～30个字节。**即使我们向该列中存储一个空字符串也会占用10个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间成为所谓的碎片。（这里你感受到设计Compact行格式的大佬既想节省存储空间，又不想更新CHAR(M)类型的列产生碎片时的纠结心情了吧。）**

# 自我认知思考
因为自己转正答辩，然后被公司的大佬技术联合创始人说了自己看问题不够抽象，看不到本质，然后需要多规纳总结，得到案例背后的模板，用模板思维再去推演问题


# 运动
30分钟

60仰卧起坐，30卧抬起

散步+小跑

# 总结
加2个自信币和2个自信点