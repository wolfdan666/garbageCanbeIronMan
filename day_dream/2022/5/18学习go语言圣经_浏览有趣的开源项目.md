# 技术
## go语言圣经
60分钟 下次从这里开始: https://books.studygolang.com/gopl-zh/ch3/ch3-05.html

### 关于golang %
取模运算符%仅用于整数间的运算。对于不同编程语言，%取模运算的行为可能并不相同。**在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。**

### golang &^ 运算符 位清空（AND NOT）
&^ 运算符
0110 &^ 1011 = 0100
1011 &^ 1101 = 0010

&^ 二元运算符的操作结果是“bit clear"
a &^ b 的意思就是 清零a中，ab都为1的位

### 进制
当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式，就像下面的例子：
```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// Output:
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```
请注意fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。

### float
一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：
```go
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
```

其中的svg三维图的详细原理没有深究...我是学golang，不是学去复习学习几何知识，聚焦重点

复数部分的画图原理同理不过多研究

### bool
因为&&的优先级比||高（助记：&&对应逻辑乘法，||对应逻辑加法，乘法比加法优先级要高），下面形式的布尔表达式是不需要加小括弧的：
```go
if 'a' <= c && c <= 'z' ||
    'A' <= c && c <= 'Z' ||
    '0' <= c && c <= '9' {
    // ...ASCII letter or digit...
}
```

## 浏览有趣的开源项目
**网站、电子邮箱、RSS 信息流、XMPP 聊天协议。所有这些技术的共同点是他们允许人们自由地互动和创造内容，没有中间人。**

40分钟: https://github.com/chainfeeds/RSSAggregatorforWeb3

# 锻炼
20分钟

# 总结
加2个自信币和2个自信点